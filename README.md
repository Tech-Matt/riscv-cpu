# riscv-cpu
A RISC-V non pipelined RV32I cpu implementation in VHDL, using AMD Vivado Software.

Read Github [Wiki](https://github.com/Tech-Matt/riscv-cpu/wiki) for more details.

## Overview
![image](https://github.com/user-attachments/assets/d14bb4e3-7c2d-4a18-9439-53f07ec98cef)

The CPU I will implement will have the following properties:
- Support for a subset of RV32I;
- 31 general purpose registers (32 bit), 1 program counter;
- Harvard Architecture;
- Instruction Memory implemented as a single port ROM BRAM;
- Data Memory Implemented as a single port RAM BRAM;

## Instruction Memory
Instruction memory will consist of a ROM BRAM (Read only memory Block RAM), with a width of 32 bits (instruction size, RISC-V like) and a depth of 4096 instructions. The block memory is defined as a single port ROM, that's because we are only interested in reading the hardcoded RISC-V instructions inside of it. The BRAM will have an enable pin and a synchronous reset pin (will only work when memory is enabled). 
The IP will have an embedded output register where the Instruction to be decoded is saved before the instruction decode stage.
The input address is 32 bit wide to ease RISC-V jump instructions. For this time the load_en for the instruction memory will be hard-wired to "1".

## Register File
Register File is made of a DRAM (Distributed Memory), with two ports, defined with a width of 32 bits (RISC-V Registers size) and 32 words deep (RISC-V ISA defines 32 registers for the register file). For now the **output** is registered.

## Data Memory
Data Memory will be implemented as a single port RAM BRAM, with 32 bit width and 4096 blocks of depth. Made of 4096 words of 32 bits. Address is 12 bits. write_en generated by control state machine.

## Clock
Clock is now set at 50 MHz. Testing need to be done.

## Instruction Fetch Stage

![image](https://github.com/user-attachments/assets/8700b4ea-cb5c-4315-8663-80a18aff4140)

The entire instruction fetch stage is executed in one clock cycle. Here is the flow of operations:

- If LOAD_EN is active, incoming PC from upper stages is loaded into the PC register (beware, this happens 1 clock cycle before the start of the instruction fetch)
- Rising edge of the clock arrives
- BRAM Instruction Memory fetches instruction reading PC if LOAD_EN_MEM is active. A synchronous RST may reset the Instruction Memory
- In the meantime PC + 4 is computed and saved in NPC (Next Program Counter)
- BRAM will save Instruction in internal IR (instruction register) before the arrival of the next clock pulse

| Signal Name | Direction | Type                        | Function                                                                 |
|-------------|-----------|-----------------------------|--------------------------------------------------------------------------|
| clk         | in        | std_logic                   | Clock signal that drives the registers of PC, block RAM, NPC, and IR.    |
| pc_in       | in        | unsigned(31 downto 0)       | Program counter input coming from other stages.                         |
| load_en     | in        | std_logic                   | Load enable signal to activate or deactivate writing on the PC register (active low). |
| res         | in        | std_logic                   | Synchronous reset for instruction memory (active high).                 |
| instr_out   | out       | std_logic_vector(31 downto 0)| Instruction fetched from instruction memory.                            |
| current_pc  | out       | unsigned(31 downto 0)       | Current program counter connected to the next stages.                   |
| next_pc     | out       | unsigned(31 downto 0)       | Next program counter value (PC + 4 bytes).                              |
| pc          | internal  | unsigned(31 downto 0)       | Internal signal for the current program counter.                        |
| instr       | internal  | std_logic_vector(31 downto 0)| Internal signal for the instruction fetched from instruction memory.    |

## Instruction Decode Stage
![image](https://github.com/user-attachments/assets/443186e3-aafc-49e8-b343-46ff2ccb3d1a)

**The Instruction Decode (ID)** stage is responsible for interpreting the fetched instruction. It extracts the necessary control signals and operands required for the Execute stage. This stage reads the instruction, decodes it, reads the necessary register values, and generates immediate values and control signals.

**Decoder Block**
The Decoder block is part of the Instruction Decode stage. It takes a 32-bit instruction and extracts relevant fields such as opcode, func3, func7, and register addresses. Based on the opcode and func3, it generates control signals and immediate values.

#### Instruction Decode Signals

| Signal Name   | Direction | Type                        | Function                                                                                   |
|---------------|-----------|-----------------------------|--------------------------------------------------------------------------------------------|
| clk           | in        | std_logic                   | Clock signal.                                                                              |
| instr         | in        | std_logic_vector(31 downto 0)| Instruction coming from the Instruction Fetch stage.                                       |
| write_en      | in        | std_logic                   | Enables writing to the register file.                                                      |
| rd_value      | in        | unsigned(31 downto 0)       | Value to be written to the register file.                                                  |
| rd_wr_enable  | in        | std_logic                   | Chooses between reading and writing to the register file (0 = read, 1 = write).            |
| rs1_val       | out       | std_logic_vector(31 downto 0)| Value of the first source register.                                                        |
| rs2_val       | out       | std_logic_vector(31 downto 0)| Value of the second source register.                                                       |
| immediate     | out       | unsigned(31 downto 0)       | Extended 32-bit immediate value.                                                           |
| op_class      | out       | std_logic_vector(4 downto 0)| Indicates the type of operation (encoded one-hot: OP, Store, Load, Branch, Jump).          |
| alu_opcode    | out       | std_logic_vector(2 downto 0)| ALU operation code.                                                                        |
| cond_opcode   | out       | std_logic_vector(2 downto 0)| Conditional operation code.                                                                |
| a_sel         | out       | std_logic                   | Controls the multiplexer A in the Execute stage (0: pc, 1: rs1_value).                      |
| b_sel         | out       | std_logic                   | Controls the multiplexer B in the Execute stage (0: immediate, 1: rs2_value).               |
| rs1           | internal  | std_logic_vector(4 downto 0)| Address of the first source register.                                                      |
| rs2           | internal  | std_logic_vector(4 downto 0)| Address of the second source register.                                                     |
| rd            | internal  | std_logic_vector(4 downto 0)| Address of the destination register.                                                       |
| imm_12        | internal  | std_logic_vector(11 downto 0)| 12-bit immediate value.                                                                    |
| imm_32        | internal  | unsigned(31 downto 0)       | Extended 32-bit immediate value.                                                           |
| r_input       | internal  | std_logic_vector(4 downto 0)| Input to the register file multiplexer for read/write selection.                           |
| op_c          | internal  | std_logic_vector(4 downto 0)| Internal signal for the operation class.                                                   |
| alu_op        | internal  | std_logic_vector(2 downto 0)| Internal signal for the ALU operation code.                                                |
| cond_op       | internal  | std_logic_vector(2 downto 0)| Internal signal for the conditional operation code.                                        |
| a             | internal  | std_logic                   | Internal signal for the multiplexer A selection.                                           |
| b             | internal  | std_logic                   | Internal signal for the multiplexer B selection.                                           |

#### Decoder Signals

| Signal Name   | Direction | Type                        | Function                                                                                   |
|---------------|-----------|-----------------------------|--------------------------------------------------------------------------------------------|
| instr         | in        | std_logic_vector(31 downto 0)| 32-bit instruction to be decoded.                                                          |
| op_class      | out       | std_logic_vector(4 downto 0)| Indicates the type of operation (one-hot encoded).                                         |
| alu_opcode    | out       | std_logic_vector(2 downto 0)| ALU operation code based on func3 and func7.                                               |
| cond_opcode   | out       | std_logic_vector(2 downto 0)| Conditional operation code based on func3.                                                 |
| rd            | out       | std_logic_vector(4 downto 0)| Address of the destination register.                                                       |
| rs1           | out       | std_logic_vector(4 downto 0)| Address of the first source register.                                                      |
| rs2           | out       | std_logic_vector(4 downto 0)| Address of the second source register.                                                     |
| immediate     | out       | std_logic_vector(11 downto 0)| 12-bit immediate value extracted from the instruction.                                     |
| a_sel         | out       | std_logic                   | Control signal for multiplexer A (0: pc, 1: rs1_value).                                    |
| b_sel         | out       | std_logic                   | Control signal for multiplexer B (0: immediate, 1: rs2_value).                             |
| func3         | internal  | std_logic_vector(2 downto 0)| Function field from the instruction (bits 14-12).                                          |
| func7         | internal  | std_logic_vector(6 downto 0)| Function field from the instruction (bits 31-25).                                          |
| opcode        | internal  | std_logic_vector(6 downto 0)| Opcode field from the instruction (bits 6-0).                                              |


## Todo

<ins> Max Priority </ins>

<ins> Normal </ins>
- [ ] Remember to pur default variable value everywhere, otherwise latches could be inferred
- [ ] Write table of signals for instruction fetch
- [ ] Write table of signals for instruction decode
- [ ] Create alu_opcode table

<ins> To be done one day in the future </ins>
- [ ] Chose a standard for variables in vhdl, uppercase or lowercase?
- [ ] See in instruction decode if it is best to keep std_logic_vector for some signals, or change it to unsigned
- [ ] See if concurrent execution can be converted to processes or vice versa
- [ ] You could add flags to alu operations



## Implementation Comments

