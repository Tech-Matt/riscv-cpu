# riscv-cpu
A RISC-V RV32I cpu implementation in VHDL, using AMD Vivado Software.

Read Github [Wiki](https://github.com/Tech-Matt/riscv-cpu/wiki) for more details.

## Overview
![image](https://github.com/user-attachments/assets/d14bb4e3-7c2d-4a18-9439-53f07ec98cef)

The CPU I will implement will have the following properties:
- Support for a subset of RV32I;
- 31 general purpose registers (32 bit), 1 program counter;
- Harvard Architecture;
- Instruction Memory implemented as a single port ROM BRAM;
- Data Memory Implemented as a single port RAM BRAM;

## Instruction Memory
Instruction memory will consist of a ROM BRAM (Read only memory Block RAM), with a width of 32 bits (instruction size, RISC-V like) and a depth of 4096 instructions. The block memory is defined as a single port ROM, that's because we are only interested in reading the hardcoded RISC-V instructions inside of it. The BRAM will have an enable pin and a synchronous reset pin (will only work when memory is enabled). 
The IP will have an embedded output register where the Instruction to be decoded is saved before the instruction decode stage.
The input address is 32 bit wide to ease RISC-V jump instructions. For this time the load_en for the instruction memory will be hard-wired to "1".

## Register File
Register File is made of a DRAM (Distributed Memory), with two ports, defined with a width of 32 bits (RISC-V Registers size) and 32 words deep (RISC-V ISA defines 32 registers for the register file). For now the **output** is registered.

## Data Memory
Data Memory will be implemented as a single port RAM BRAM, with 32 bit width and 4096 blocks of depth. Made of 4096 words of 32 bits. Address is 12 bits. write_en generated by control state machine.

## Clock
Clock is now set at 50 MHz. Testing need to be done.

## Instruction Fetch Stage

![image](https://github.com/user-attachments/assets/8700b4ea-cb5c-4315-8663-80a18aff4140)

The entire instruction fetch stage is executed in one clock cycle. Here is the flow of operations:

- If LOAD_EN is active, incoming PC from upper stages is loaded into the PC register (beware, this happens 1 clock cycle before the start of the instruction fetch)
- Rising edge of the clock arrives
- BRAM Instruction Memory fetches instruction reading PC if LOAD_EN_MEM is active. A synchronous RST may reset the Instruction Memory
- In the meantime PC + 4 is computed and saved in NPC (Next Program Counter)
- BRAM will save Instruction in internal IR (instruction register) before the arrival of the next clock pulse

## Todo

<ins> Max Priority </ins>

<ins> Normal </ins>
- [ ] Remember to pur default variable value everywhere, otherwise latches could be inferred
- [ ] Write table of signals for instruction fetch
- [ ] Write table of signals for instruction decode
- [ ] Create alu_opcode table

<ins> To be done one day in the future </ins>
- [ ] Chose a standard for variables in vhdl, uppercase or lowercase?
- [ ] See in instruction decode if it is best to keep std_logic_vector for some signals, or change it to unsigned
- [ ] See if concurrent execution can be converted to processes or vice versa
- [ ] You could add flags to alu operations



## Implementation Comments

